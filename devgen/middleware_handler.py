# Generates a device description dictionnary and code fragments 
# from a tagged C++ header file
#
# (c) Koheron

import os
import time
import yaml
import string

from hpp_parser import parse_header, CSTR_TYPES

class MiddlewareHandler:
    def __init__(self, hppfile):
       self.parser =  MiddlewareHppParser(hppfile)
       
    def generate_device_description_file(self, path):
        """ Generate the device description dictionnary """
        d2l_filename = os.path.join(path, self.parser.get_device_name().lower() + ".yaml")
        f = open(d2l_filename, 'w')
        
        f.write('# Device description file for ' + self.parser.raw_dev_data["name"] + '\n')
        f.write('#\n')
        f.write('# Generated by devgen.\n')
        f.write('# DO NOT EDIT.\n')
        f.write('#\n')
        f.write('# ' + time.strftime("%c") + "\n")
        f.write('# (c) Koheron\n\n')

        yaml.dump(self.parser.device, f, indent=2, default_flow_style=False)
        f.close()
        
        return d2l_filename
        
    def get_device_data(self):
        # self.generate_device_description_file('./tmp')
        return self.parser.device

    def get_fragments(self):
        frag_gen = FragmentsGenerator(self.parser)
        return frag_gen.get_fragments()

class MiddlewareHppParser:
    def __init__(self, hppfile):
        devices = parse_header(hppfile)
        self.raw_dev_data = devices[0]
        self.raw_dev_data["includes"] = [self._get_include(hppfile)];
        self.device = self._get_device()

    def _get_include(self, hppfile):
        folders = hppfile.split('/')
        middleware_idx = -1
        for idx, folder in enumerate(folders):
            if folder == "drivers":
                middleware_idx = idx
                break

        if middleware_idx == -1:
            raise ValueError("Source file must be in the drivers folder")

        return '/'.join(folders[(middleware_idx+1):])

    def _get_template(self, ret_type):
        tokens = ret_type.split('<')
        
        if len(tokens) == 2:
            return tokens[1].split('>')[0].strip()
        else:
            return None
        
    def _get_device(self):
        device = {}
        device["operations"] = []
        device["name"] = self.get_device_name()
        device["description"] = ""            
        device["includes"] = self.raw_dev_data["includes"]
        device["objects"] = [{
          "type": self.raw_dev_data["objects"][0]["type"],
          "name": "__" + self.get_device_name().lower()
        }]

        for op in self.raw_dev_data["operations"]:
            device["operations"].append(self._format_operation(op))

        return device

    def get_device_name(self):
        """ Build the device name from the class name """
        raw_name = self.raw_dev_data["name"]
        dev_name = []

        # Check whether there are capital letters within the class name
        # and insert an underscore before them
        for idx, letter in enumerate(raw_name):
            if idx > 0 and letter in list(string.ascii_uppercase):
                dev_name.append('_')

            dev_name.append(letter.upper())

        return ''.join(dev_name)

    def _format_operation(self, op):
        operation = {}
        operation["name"] = op["prototype"]["name"].upper()

        if "description" in op and op["description"] != "":
            operation["description"] = op["description"]

        if "flags" in op and len(op["flags"]) > 0:
            operation["flags"] = op["flags"]

        if op["io_type"]["value"] == "WRITE_ARRAY":            
            send_buffer_flag = {
              "name": "SEND_BUFFER",
              "buffer_name": [op["array_params"]["name"]["name"]]
            }

            if len(op["flags"]) > 0:
                operation["flags"].append(send_buffer_flag)
            else:
                operation["flags"] = [send_buffer_flag]

        if len(op["prototype"]["params"]) > 0:
            if op["io_type"]["value"] == "WRITE_ARRAY":                
                array_name_ok = False
                array_length_ok = False

                for param in op["prototype"]["params"]:
                    param_ptr_toks = param["name"].split('*')

                    if (op["array_params"]["name"]["src"] == "param" and 
                        len(param_ptr_toks) == 2 and
                        param_ptr_toks[1].strip() == op["array_params"]["name"]["name"]):
                        array_name_ok = True
                    elif (op["array_params"]["name"]["src"] == "param" and 
                        len(param_ptr_toks) == 1 and
                        param_ptr_toks[0].strip() == op["array_params"]["name"]["name"]):
                        array_name_ok = True
                    else:
                        if (op["array_params"]["length"]["src"] == "param" and 
                            param["name"] == op["array_params"]["length"]["length"]):
                            array_length_ok = True

                        arg = {}
                        arg["name"] = param["name"]
                        arg["type"] = param["type"]
                        arg["description"] = ""

                        if "arguments" in operation:
                            operation["arguments"].append(arg)
                        else:
                            operation["arguments"] = [arg]

                if not array_name_ok or not array_length_ok:
                    raise ValueError('write_array arguments not found in function prototype')
            else:
                operation["arguments"] = []

                for param in op["prototype"]["params"]:
                    arg = {}
                    arg["name"] = param["name"]
                    arg["type"] = param["type"]
                    arg["description"] = ""
                    operation["arguments"].append(arg)

        return operation
        
class FragmentsGenerator:
    def __init__(self, parser):
        self.parser = parser
        
    def get_fragments(self):
        fragments = []
        
        for op in self.parser.raw_dev_data["operations"]:
            op_name = op["prototype"]["name"].upper()
            frag = {}
            frag["name"] = op_name
            frag["fragment"] = self.generate_fragment(op_name)
            fragments.append(frag)
        
        # Add is_failed fragment 
        frag = {}
        frag["name"] = "IS_FAILED"
        frag["fragment"] = [self._gen_is_failed_fragment()]
        fragments.append(frag)
        
        return fragments
        
    def generate_fragment(self, op_name):
        """ Generate the fragment of an operation """
        operation = self._get_operation_data(op_name)
        frag = []
        
        if operation["io_type"]["value"] == "WRITE":
            frag.append("    " + self._build_func_call(operation) + ";\n")
            frag.append("    return 0;\n")
        elif operation["io_type"]["value"] == "READ":
            template = self.parser._get_template(operation["prototype"]["ret_type"])
        
            if (operation["prototype"]["ret_type"] == "uint32_t"
                or operation["prototype"]["ret_type"] == "unsigned int"
                or operation["prototype"]["ret_type"] == "unsigned long"
                or operation["prototype"]["ret_type"] == "int"
                or operation["prototype"]["ret_type"] == "int32_t"
                or operation["prototype"]["ret_type"] == "bool"):
                frag.append("    return SEND<uint32_t>(" 
                            + self._build_func_call(operation) + ");\n")
            elif (operation["prototype"]["ret_type"] == "uint64_t"
                  or operation["prototype"]["ret_type"] == "unsigned long long"):
                frag.append("    return SEND<uint64_t>(" 
                            + self._build_func_call(operation) + ");\n")
            elif (operation["prototype"]["ret_type"] == "float"):
                frag.append("    return SEND<float>(" 
                            + self._build_func_call(operation) + ");\n")
            elif template != None:
                type_base = operation["prototype"]["ret_type"].split('<')[0].strip()
                
                if (type_base == "std::vector"
                    or type_base == "std::array" 
                    or type_base == "std::tuple"):
                    frag.append("    return SEND<" + template + ">(" 
                                + self._build_func_call(operation) + ");\n")
            else:
                raise ValueError("No available interface to send type " 
                                 + operation["prototype"]["ret_type"])
        
        elif operation["io_type"]["value"] == "READ_CSTR":
            if operation["prototype"]["ret_type"] not in CSTR_TYPES:
                raise ValueError("I/O type READ_CSTR expects a char*. Found " 
                                 + operation["prototype"]["ret_type"] + ".\n")

            frag.append("    return SEND_CSTR(" 
                        + self._build_func_call(operation) + ");\n")
            
        elif operation["io_type"]["value"] == "READ_ARRAY":
            ptr_type = self._get_ptr_type(operation["prototype"]["ret_type"])
            remaining = operation["io_type"]["remaining"]
            
            if remaining.find('this') >= 0:
                obj_name = self.parser.device["objects"][0]["name"]
                member_name = remaining.split('{')[1].split('}')[0].strip()
                member_call = "THIS->" + obj_name + "." + member_name
                length = remaining.replace('this{' + member_name + '}', member_call)
            elif remaining.find('arg') >= 0:
                length = ""
                for param in operation["prototype"]["params"]:
                    if remaining.find(param['name']) >= 0:
                        length = remaining.replace('arg{' + param['name'] + '}', "args." + param['name'])
                if length == "": # Length is a constant independent of a parameter
                    length = remaining
            else: # Length is a constant independent of a parameter
                length = remaining
            
            frag.append("    return SEND_ARRAY<" + ptr_type + ">(" 
                        + self._build_func_call(operation) + ", " + length + ");\n")
                            
        elif operation["io_type"]["value"] == "WRITE_ARRAY":
            len_name = operation["array_params"]['length']['length']
            
            frag.append("    const uint32_t *data_ptr = RCV_HANDSHAKE(args." + len_name + ");\n\n")
            frag.append("    if (data_ptr == nullptr)\n")
            frag.append("       return -1;\n\n")
            frag.append("    " + self._build_write_array_func_call(operation) + ";\n\n")
            frag.append("    return 0;\n")
                            
        # self._show_fragment(frag)
        return frag

    def _get_ptr_type(self, ret_type):
        """Get the pointer type
        Ex. if ret_type is char* it returns char.
        Raise an error if ret_type is not a pointer.
        """
        tokens = ret_type.split('*')
        
        # T*
        if len(tokens) == 2:
            return tokens[0].strip()
        # const T*
        elif tokens[0].split(' ')[0].strip() == "const" and len(tokens) == 2:
            return tokens[0].split(' ')[1].strip()
        else:
            raise ValueError("Return type " + ret_type + " is not a pointer")
        
    def _get_operation_data(self, op_name):
        for op in self.parser.raw_dev_data["operations"]:
            if op["prototype"]["name"].upper() == op_name:
                return op
                
        raise ValueError("Unknown operation " + op_name)
        
    def _build_func_call(self, operation):
        obj_name = self.parser.device["objects"][0]["name"]
        func_name = operation["prototype"]["name"]
        
        call = "THIS->" + obj_name + "." + func_name + "("
        
        for count, param in enumerate(operation["prototype"]["params"]):
            if count == 0:
                call += "args." + param["name"]
            else:
                call += ", args." + param["name"]
        
        call += ")" 
        
        return call
        
    def _build_write_array_func_call(self, operation):
        assert operation["io_type"]["value"] == "WRITE_ARRAY"
        len_name = operation["array_params"]['length']['length']
        obj_name = self.parser.device["objects"][0]["name"]
        func_name = operation["prototype"]["name"]

        call = "THIS->" + obj_name + "." + func_name + "("

        for count, param in enumerate(operation["prototype"]["params"]):
            param_ptr_toks = param["name"].split('*')
            
            if ((operation["array_params"]["name"]["src"] == "param" and 
                len(param_ptr_toks) == 2 and 
                param_ptr_toks[1].strip() == operation["array_params"]["name"]["name"]) or
                (operation["array_params"]["name"]["src"] == "param" and 
                len(param_ptr_toks) == 1 and 
                param_ptr_toks[0].strip() == operation["array_params"]["name"]["name"])):
                
                if count == 0:
                    call += "data_ptr"
                else:
                    call += ", data_ptr"
            elif (operation["array_params"]["length"]["src"] == "param" and 
                  param["name"] == operation["array_params"]["length"]["length"]):
                if count == 0:
                    call += "args." + len_name
                else:
                    call += ", args." + len_name
            else:
                if count == 0:
                    call += "args." + param["name"]
                else:
                    call += ", args." + param["name"]
        
        call += ")" 
        
        return call
        
    def _show_fragment(self, fragment):
        print ''.join(fragment)
        
    def _gen_is_failed_fragment(self):
        if "is_failed" in self.parser.raw_dev_data:
            obj_name = self.parser.device["objects"][0]["name"]
            func_name = self.parser.raw_dev_data["is_failed"]["name"]
            return "    return THIS->" + obj_name + "." + func_name + "();\n"
        else:
            return "    return false;\n"
  
